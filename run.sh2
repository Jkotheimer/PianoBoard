#!/usr/bin/env bash
# run.sh
# 
# @author: Jack Kotheimer
# @date: 12/5/2020
# @owner EzClinic
#
# The main functionality of the script is listed just below in the '_help' function, but if you have any questions about
# the functionality or implementation of this script, feel free to send me a message via email at jkotheimer9@gmail.com
#
# Enjoy!
if [ $EUID -eq 0 ]; then
	_warn 'Hold your horses! You are running this script as root, meaning other users will not be able to access many of the generated server resources.'
	read -r -n 1 -p 'Are you sure you wish to continue? [y/N] ' choice
	echo
	[[ ${choice^^} != 'Y' ]] && exit 1
fi
mkdir -p logs/

###############################################################################
# -----------------------------------------------------------------------------
# PRETTY PRINTERS/ COMMAND HANDLER
# -----------------------------------------------------------------------------
###############################################################################

# Just some colorful output handlers to satisfy those who enjoy clean script responses
red=$'\033[0;31m'
yellow=$'\033[0;33m'
green=$'\033[0;32m'
blue=$'\033[0;34m'
nc=$'\033[0m'

# Print something in color
# $1: String to print
# $2: Color to print with
echoc() {
	printf "%s%s%s\n" "$2" "$1" "$nc"
}
# Print the description of a command before its execution
_print() {
	[ "$VERBOSE" -eq 1 ] && printf "%s...\n" "$@" || printf '[ .... ] %s' "$@"
}
_ok() {
	printf "\r[%s DONE %s]\n" "$green" "$nc"
}
_warn() {
	printf "\r[%s WARN %s] %s\n" "$yellow" "$nc" "$1"
}
# $1: Error message
# $2: (optional) '-' to print the error message inline with the [ FAIL ] flag
_err() {
	printf "\r[%s FAIL %s] " "$red" "$nc"
	[ -z "$2" ] && printf "\n"
	printf "%s\n" "$1"
	exit 1
}
# $1: Command to execute and handle
# $2: (optional) log file to save command output to
# $3: (optional) '-' to put an '&' after command to make it a background process
_handle() {
	# If a log file was specified, set it to the output variable
	LOG=logs/temp.log
	[ -n "$2" ] && LOG=logs/$2 
	STAT=0
	# If the daemon flag is set, send the command to the daemons
	if [ -n "$3" ]; then
		if [ "$VERBOSE" -eq 1 ]; then
			$1 | tee "$LOG" &
			STAT=${PIPESTATUS[0]}

			# If the daemon flag was a '/' under verbose mode, wait for the command to resolve
			# This is typically done if the command is the last command in a series, and you want to view it's output
			if [ "$3" = '-' ]; then
				wait
			else
				sleep 3
			fi
		else
			$1 &>"$LOG" &
			STAT=$?
			sleep 3
		fi
	else
		if [ "$VERBOSE" -eq 1 ]; then
			$1 | tee "$LOG"
			STAT=${PIPESTATUS[0]}
		else
			$1 &>"$LOG"
			STAT=$?
		fi
	fi

	# If the status was successful, print [ DONE ], else exit with the status code of the command
	if [ "$STAT" -eq 0 ]; then
		_ok
		[[ "$VERBOSE" -ne 1 && -n "$2" ]] && echoc "Log: $LOG" "$blue"
	else 
		if [ "$VERBOSE" -eq 1 ]; then
			_err "Status: $STAT" -
		else
			_err "$(tail -n 15 "$LOG")"
		fi
	fi
	return "$STAT"
}

###############################################################################
# -----------------------------------------------------------------------------
# HELP MENU
# -----------------------------------------------------------------------------
###############################################################################
_help() {
	# figlet is used to make bubble letters!
	FIG=0
	command -v figlet &>/dev/null && FIG=1 || echo Install figlet for bubble letters on your app name!
	
	echoc '-------------------------------------------------------------------' "$blue"
	printf '%s' "$blue"
	[ "$FIG" -eq 1 ] && figlet "$APP" || echo "$APP"
	echoc '-------------------------------------------------------------------' "$blue"
	echo 
	echo 'This script contains several functions to automate the software development process'
	echo 'Only one function may be executed at a time'
	echo 
	echo 'If you wish to add an operation to this script, contain it to a single function and add it to the'
	echo 'case statement at the bottom of this file. Document the function it serves in this help menu, and'
	echo 'create a pull request :)'
	echo 
	echoc '-----------------------------------------------' "$blue"
	echoc '|           HOW TO USE THIS SCRIPT            |' "$blue"
	echoc '-----------------------------------------------' "$blue"
	echoc './run.sh <primary> <secondary>' "$yellow"
	echo  '   <primary>   : (required) is any one of the below commands (a secondary command may be used as a primary)'
	echo  '   <secondary> : (optional) is any combination of secondary commands'
	echo 
	echoc '####################' "$blue"
	echoc '# ---------------- #' "$blue"
	printf "%s# %sPRIMARY COMMANDS %s#\n" "$blue" "$nc" "$blue"
	echoc '# ---------------- #' "$blue"
	echoc '####################' "$blue"
	echo 'Only one of these may be used at a time.'
	echo '----------------------------------------'
	echo '--boot         [-o]: Boot up the container without starting the server. (good for server debugging)'
	echo '--deploy       [-d]: Deploy the server'
	echo '    Dependencies from .config'
	echo '        - ENV: Environment to deploy to (dev, staging, production). See --env below'
	echo '        - TAG: Docker image tag to deploy with. See --tag below'
	echo '--manage <cmd> [-m]: Shortcut for ./manage.py (runs inside the docker container)'
	echo '    <cmd> : command to pass to manage.py'
	echo 
	echoc '######################' "$blue"
	echoc '# ------------------ #' "$blue"
	printf "%s# %sSECONDARY COMMANDS %s#\n" "$blue" "$nc" "$blue"
	echoc '# ------------------ #' "$blue"
	echoc '######################' "$blue"
	echo 'Any number of these commands can be used in one call of this script in any order.'
	echo '---------------------------------------------------------------------------------'
	echoc 'Pre-primary -------------------------------------------------------' "$yellow"
	echo '--verbose     [-v]: Display verbose output on the primary function'
	echo '--kill        [-k]: Kill the docker container'
	echo '--pull        [-p]: Pull an image from Docker Hub'
	echo '--build       [-b]: Build a new Docker image'
	echo '--migrate     [-g]: Make migrations inside Docker container'
	echo '--env <env>   [-e]: Switch environments to work in'
	echo '    <env> : dev, staging, or production'
	echoc "    Environment currently set to '$ENV'" "$green"
	echo '--tag <tag>   [-t]: Checkout a new tag name for your image'
	echo '    <tag> : Any string as a tag name'
	echoc "    Tag currently set to '$TAG'" "$green"
	echo '--host <host> [-H]: Set the host of the image for the current environment'
	echo "    <host>: The host to which you wish to push and pull the $ORG/${APP}_$ENV:$TAG image"
	echoc "    Docker image host for $ENV currently set to '${DHOSTS[$ENV]}'" "$green"
	echoc 'REMOTE SPECIFIC' "$yellow"
	echo '--rebuild     [-r]: Rebuild ecs cluster (when switching between machines to use new ssh keypair)'
	echo '--aws-cred        : Re-enter AWS credentials'
	NCOLOR="$green"
	if [[ -z "$AWS_ACCESS_KEY_ID" || -z "$AWS_SECRET_ACCESS_KEY" ]]; then
		CREDSTAT=' not'
		NCOLOR="$red"
	fi
	echoc "    AWS credentials are currently$CREDSTAT set" "$NCOLOR"
	echo '--aws-region <reg>: Set the AWS region to deploy to (default: us-east-1)'
	echo '    <reg> : Any AWS region'
	NCOLOR="$green"
	[ -z "$AWS_DEFAULT_REGION" ] && NCOLOR="$red"
	echoc "    AWS region is currently set to '$AWS_DEFAULT_REGION'" "$NCOLOR"
	echo '--keypair <kp>    : Set the keypair to use when deploying remotely'
	echo '    <kp>  : An AWS registered ssh keypair name'
	NCOLOR="$green"
	[ -z "$KEYPAIR" ] && NCOLOR="$red"
	echoc "    AWS keypair is currently set to '$KEYPAIR'" "$NCOLOR"
	echo 
	echoc 'Post-primary ------------------------------------------------------' "$yellow"
	echo '--help        [-h]: Show this help menu'
	echo '--push        [-u]: Push a recently built image to Docker Hub'
	echo '--clean       [-c]: Clean all dangling docker images'
	echo '--dockershell [-l]: Enter the development docker container command line'
	echo '--db-connect      : Connect to a database'
	echo 
	echoc '*If no arguments are supplied, this help menu is displayed' "$yellow"
	echo 
}

###############################################################################
# -----------------------------------------------------------------------------
# DOCKER SHORTCUTS
# -----------------------------------------------------------------------------
###############################################################################

# Execute any bash command inside app container
drun() {
	# TODO: Implement for remote server ssh
	docker exec -it "$APP" "$@" || _err
}
# Create and remove docker containers
create_docker_container() {
	kill_server
	get_drp
	_print "Creating Docker container named $APP with image: $ORG/${APP}_$ENV:$TAG"
	_handle "docker run -d $DOCKER_RUN_PARAMETERS --env-file $(pwd)/deployment/$ENV/$ENV.env --env-file $(pwd)/deployment/$ENV/$ENV.secret --hostname com-$APP-app --name $APP -it $ORG/${APP}_$ENV:$TAG $1" docker-run.log
}
kill_server() {
	# TODO: Implement kill remote server (ask confirmation first)
	_print "Killing server"
	docker kill "$APP" db rabbitmq &>/dev/null
	docker rm "$APP" db rabbitmq &>/dev/null
	_ok
}
# Log in to an image host, dependant on current environment
docker_login() {
	if [ "$ENV" = dev ]; then
		docker login
	else
		aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin "${DHOSTS[$ENV]}"
	fi
}
# Push and pull containers to and from the image host
push_docker_image() {
	docker_login

	# Prepend the image host to the image tag so Docker knows where to send it
	docker tag "$ORG/${APP}_$ENV:$TAG" "${DHOSTS[$ENV]}/$ORG/${APP}_$ENV:$TAG"

	_print "Pushing image to ${DHOSTS[$ENV]}/$ORG/${APP}_$ENV:$TAG"
	_handle "docker push ${DHOSTS[$ENV]}/$ORG/${APP}_$ENV:$TAG"
}
pull_docker_image() {
	docker_login

	_print "Pulling image from ${DHOSTS[$ENV]}/$ORG/${APP}_$ENV:$TAG"
	_handle "docker pull ${DHOSTS[$ENV]}/$ORG/${APP}_$ENV:$TAG"
}
# Create and remove docker images
create_docker_image() {
	[ "$VERBOSE" -ne 1 ] && echoc 'Verbose output auto-enabled' "$yellow"
	VERBOSE=1
	remove_docker_image
	_print "Building Docker image: $ORG/${APP}_$ENV:$TAG (this may take a hot sec)"
	_handle "docker build --tag $ORG/${APP}_$ENV:$TAG --build-arg ENV=$ENV ." docker-init.log
}
remove_docker_image() {
	_print "Removing Docker image named $ORG/${APP}_$ENV:$TAG"
	docker image rm "$(docker image ls -aq "$ORG/${APP}_$ENV:$TAG")" &>/dev/null
	_ok
}
clean_docker_images() {
	DANGLING=$(docker image ls -aqf dangling=true)
	[ -z "$DANGLING" ] && echo "Nothing to clean!" && return 0
	_print 'Cleaning dangling images'
	_handle "docker image rm -f $DANGLING"
}

###############################################################################
# -----------------------------------------------------------------------------
# ECS SHORTCUTS
# -----------------------------------------------------------------------------
###############################################################################

# When switching between machines or developers, use this command to allow ssh access with your keypair
rebuild_ecs_cluster() {
	# https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cmd-ecs-cli-up.html
	echoc "Generating $ENV ECS cluster..." "$yellow"
	[ -n "$VERBOSE" ] && VB=--verbose
	ecs-cli up --cluster-config "$APP-$ENV" \
			--ecs-profile "$ORG-remote" \
			--keypair "$KEYPAIR" \
			--capability-iam \
			--size 3 \
			--instance-type t2.medium \
			--port 80 --port 3306 --port 5672 \
			--force "$VB"
}

###############################################################################
# -----------------------------------------------------------------------------
# APPLICATION SPECIFIC SHORTCUTS
# -----------------------------------------------------------------------------
###############################################################################

manage_shortcut() {
	drun /app/manage.py "$@"
}
ecs_shortcut() {
	[ "$ENV" = dev ] && _err "Operation not permitted in current environment: $ENV" -
	docker_login
	export COMPOSE_FILE="./deployment/$ENV/docker-compose.yml"
	ecs-cli "$@"
}
# Export all variables in a basic config file of key=value pairs
efile() {
	source "$1"
	export $(cut -d= -f1 "$1" | grep -v DHOSTS) &>/dev/null
}

###############################################################################
# -----------------------------------------------------------------------------
# CONFIG GENERATION
# -----------------------------------------------------------------------------
###############################################################################

# Update a variable setting in any given config file
# $1: Variable name
# $2: Variable value
# $3: (optional) config file name - default=.config
update_conf() {
	[ -z "$3" ] && conf='.config' || conf="$3"
	NAME="$(echo "$1" | tr '[]' '.*.*')"
	if grep "$NAME" "$conf" &>/dev/null; then
		sed -i '' -e "s|$NAME.*|$1=$2|g" "$conf"
	else
		echo "$1=$2" >> "$conf"
	fi
	echoc "$1 has been set to $2" "$blue"
	source "$conf"
	efile "$conf"
}
# Prompt for a config variable from user
# $1: Prompt text. (e.g. "AWS Access Key: ")
# $2: Variable name (e.g. AWS_ACCESS_KEY_ID)
# $3: Default value
prompt_conf() {
	
	if [[ "$1" == *secret* ]]; then
		read -r -s -p "$1" VALUE
	else
		read -r -p "$1" VALUE
	fi
	echo
	[ -z "$VALUE" ] && VALUE="$3"
	if [ -z "$VALUE" ]; then
		_warn 'This field cannot be left empty'
		prompt_conf "$1" "$2" "$3"
		return $?
	fi
	update_conf "$2" "$VALUE"
}
gen_app_conf() {
	echo 'ORG=ezclinic
APP=ezclinic
ENV=dev
TAG=latest
declare -A DHOSTS
DHOSTS[dev]=dockerhub.io
DHOST=${DHOSTS[$ENV]}' > .config
	source .config
	efile .config
}

# Gather info from the Dockerfile about exposed ports and copied directories and turn them into `docker run` parameters
get_drp() {
	DOCKER_RUN_PARAMETERS=''

	# Add any ports specified by EXPOSE in the Dockerfile
	while IFS= read -r p; do
		DOCKER_RUN_PARAMETERS+="-p $p:$p "
	done < <(grep EXPOSE Dockerfile | tr -dc '0-9')

	# Add any symlinked volumes specified by COPY in the Dockerfile
	local_v=''
	while IFS= read -r line; do
		for val in $line; do
			if [ "$val" = COPY ]; then
				unset local_v
			elif [ -z "$local_v" ]; then
				# If the local volume starts with a '.', replace it with $(pwd)
				if [[ "$val" =~ ^\. ]]; then
					[ ! -d "$val" ] && mkdir "$val"
					val="$(pwd)${val:1}"
				fi
				local_v="$val"
			else
				DOCKER_RUN_PARAMETERS+="-v $local_v:$val "
			fi
		done
	done < <(grep COPY Dockerfile)
}

# Verbose setter - default is off
VERBOSE=0
_verbose() {
	echoc 'Verbose output enabled' "$yellow"
	VERBOSE=1
}

###############################################################################
# -----------------------------------------------------------------------------
# REQUIREMENTS & CONFIG CHECK
# -----------------------------------------------------------------------------
###############################################################################

# Check for AWS credentials only when a remote deployment is underway
get_aws_cred() {
	prompt_conf 'AWS access key ID: ' AWS_ACCESS_KEY_ID
	prompt_conf 'AWS secret access key: ' AWS_SECRET_ACCESS_KEY
}
check_remote_conf() {
	[ -z "$AWS_DEFAULT_REGION" ] && prompt_conf 'AWS default region [default=us-east-1]: ' AWS_DEFAULT_REGION us-east-1
	[ -z "$KEYPAIR" ] && prompt_conf 'AWS keypair name: ' KEYPAIR
	[[ -z "$AWS_ACCESS_KEY_ID" || -z "$AWS_SECRET_ACCESS_KEY" ]] && get_aws_cred
	[ -z "${DHOSTS[${ENV}]}" ] && prompt_conf "Image host for $ORG/${APP}_$ENV:$TAG [default=dockerhub.io]: " "DHOSTS[$ENV]" dockerhub.io
	req_check ecs-cli aws
}

# Check for missing required software
req_check() {
	ERR=()
	for cmd in "$@"; do
		command -v "$cmd" &>/dev/null || ERR+=("$cmd")
	done
	[ ${#ERR[@]} -gt 0 ] && _err "You must install the following package(s) in order to deploy this project: ${ERR[*]}" -
}
req_check docker docker-compose

# Check for valid .config, then export all it's variables
if ! grep APP .config &>/dev/null; then
	_warn 'Invalid .config - Generating now...'
	gen_app_conf
fi
source .config
efile .config

# Ensure environment secret file is available
[ ! -f deployment/$ENV/$ENV.secret ] && _err "Invalid or missing requirement: deployment/$ENV/$ENV.secret" -

###############################################################################
# -----------------------------------------------------------------------------
# DEPLOYMENT MECHANISM
# -----------------------------------------------------------------------------
###############################################################################

# $1: (optional) Different docker-compose.yml environment to deploy to current $ENV
_deploy() {
	
	# compose path - If $1 is set to a different compose path, that compose file gets deployed to $ENV
	# It seems counterintuitive, but this acts a a good debugging tool
	CP="$ENV"
	[ -n "$1" ] && CP="$1"
	export COMPOSE_FILE="./deployment/$CP/docker-compose.yml"
	export DHOST="${DHOSTS[$ENV]}"

	# For dev, just run the compose app and get outta here
	if [ "$ENV" = dev ]; then
		_print "Deploying dev server"
		_handle "docker-compose up" -
		return
	fi

	# Check for ecs-cli and docker as well as the proper AWS credential environment variables
	check_remote_conf

	# https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cmd-ecs-cli-configure.html
	echoc "Setting ecs config for $ENV" "$blue"
	ecs-cli configure \
			--cluster "$APP-$ENV" \
			--default-launch-type EC2 \
			--config-name "$APP-$ENV" \
			--region us-east-1

	# https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cmd-ecs-cli-configure-profile.html
	ecs-cli configure profile --profile-name "$ORG-remote"

	# Attempt to start the ECS cluster as the staging app
	# https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cmd-ecs-cli-compose-service-up.html
	echoc "Composing $APP to $ENV with ECS" "$blue"
	ecs-cli compose service up \
			--cluster-config "$APP-$ENV" \
			--ecs-profile "$ORG-remote" \
			--create-log-groups
}

###############################################################################
# -----------------------------------------------------------------------------
# FLAG PARSING & FUNCTION EXECUTION
# -----------------------------------------------------------------------------
###############################################################################

# This function "converts" an argument tag (like --verbose or -v) into a function name
# @param: $1 an argument tag
# @returns: 0, 1, 2, 3, or 4
#   0: pre-primary (no follow-up value)
#   1: pre-primary (with follow-up value. e.g.: --tag <tagname>. (<tagname> is the follow-up value))
#   2: primary
#   3: primary (with multiple follow up values : no other sub-commands may be used with this)
#   4: post-primary
parse_cmd() {
	case "$1" in
		####################
		# PRIMARY COMMANDS #
		####################
		--deploy | -d)
			echo _deploy
			return 2;;
		--boot | -o)
			echo create_docker_container bash
			return 2;;
		--manage | -m)
			echo manage_shortcut
			return 3;;
		--ecs)
			echo ecs_shortcut
			return 3;;

		######################
		# SECONDARY COMMANDS #
		######################
		# Pre-primary
		# -----------
		--verbose | -v)
			echo _verbose;;
		--config | -f)
			echo gen_app_conf
			return 0;;
		# Docker shortcuts
		--kill | -k)
			echo kill_server
			return 0;;
		--pull | -p)
			echo pull_docker_image
			return 0;;
		--build | -b)
			echo create_docker_image
			return 0;;
		--migrate | -g)
			echo manage_shortcut makemigrations
			return 0;;
		# Remote specific
		--rebuild | -r)
			[ "$ENV" = dev ] && _err "Operation not allowed in current environment: $ENV"
			echo rebuild_ecs_cluster
			return 0;;
		--aws-cred)
			echo get_aws_cred
			return 0;;
		# State changers
		--tag | -t)
			echo update_conf TAG
			return 1;;
		--env | -e)
			echo update_conf ENV
			return 1;;
		--host | -H)
			echo update_conf DHOSTS["$ENV"]
			return 1;;
		--keypair)
			echo update_conf KEYPAIR
			return 1;;
		--aws-region)
			echo update_conf AWS_DEFAULT_REGION
			return 1;;

		# Post-primary
		# ------------
		--help | -h)
			echo _help
			return 4;;
		--test)
			echo manage_shortcut test
			return 4;;
		--dockershell | -l)
			echo docker exec -it "$APP" bash
			return 4;;
		--db-connect)
			echo db_connect
			return 4;;
		--push | -u)
			echo push_docker_image
			[ "$ENV" = dev ] && return 4 || return 0;;
		--clean | -c)
			echo clean_docker_images
			return 4;;
		
		#########
		# Error #
		#########
		*)
			return 255;;
	esac
}

# The pre- and post-primary commands are placed in separate arrays to be executed at their respective times
PRE=()
PRIMARY=''
POST=()
var_set=''
for cmd in "$@"; do

	# If the last cmd was a variable setter (e.g. --tag or --env), append the current cmd (which would be the value) to that function call, then continue
	if [ -n "$var_set" ]; then
		
		# Spelling autocorrect based on the first letter of environment
		if [ "${var_set//* }" = ENV ]; then
			case "${cmd:0:1}" in
				d)
					cmd=dev;;
				s)
					cmd=staging;;
				p)
					cmd=production;;
				*)
					_err "Invalid environment: $cmd" -
			esac
		fi

		# Add the function call to the pre-primary commands, reset and continue parsing
		PRE+=( "$var_set $cmd" )
		unset var_set
		continue
	fi
	
	# Verbose mode should be the very first thing to be executed, so if it was set, enable verbose now
	[[ "$cmd" = --verbose || "$cmd" = -v ]] && _verbose && continue

	next=$(parse_cmd "$cmd")
	case "$?" in
		0)
			PRE+=( "$next" );;
		1)
			var_set="$next";;
		2)
			[ -n "$PRIMARY" ] && _err "Multiple primary command issued: $cmd" -
			PRIMARY="$next";;
		3)
			shift
			$next "$@"
			exit $?;;
		4)
			POST+=( "$next" );;
	esac
done

[[ -z "$PRE" && -z "$PRIMARY" && -z "$POST" ]] && _help && exit 1

# Execute the commands in proper order
for cmd in "${PRE[@]}"; do $cmd; done
$PRIMARY
for cmd in "${POST[@]}"; do $cmd; done
